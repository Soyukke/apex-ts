use crate::parser::{ApexClass, ApexMethod};

pub struct TypeScriptGenerator;

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self
    }

    pub fn generate(&self, classes: &[ApexClass]) -> String {
        let mut output = String::new();
        
        output.push_str("// Auto-generated TypeScript definitions from Apex classes\n");
        output.push_str("// Generated by apex-ts\n\n");

        for class in classes {
            output.push_str(&self.generate_class_definition(class));
            output.push_str("\n\n");
        }

        output
    }

    fn generate_class_definition(&self, class: &ApexClass) -> String {
        let mut output = String::new();
        
        // インターフェース生成（フィールド用）
        if !class.fields.is_empty() {
            output.push_str(&self.generate_interface(class));
        }

        // メソッドがある場合は @salesforce/apex 形式で生成
        if !class.methods.is_empty() {
            if !class.fields.is_empty() {
                output.push_str("\n\n");
            }
            output.push_str(&self.generate_apex_methods(class));
        }

        output
    }

    fn generate_interface(&self, class: &ApexClass) -> String {
        let mut output = String::new();
        
        output.push_str(&format!("export interface {} {{\n", class.name));

        for field in &class.fields {
            let ts_type = self.convert_apex_type_to_ts(&field.field_type);
            let optional_marker = if field.is_optional { "?" } else { "" };
            output.push_str(&format!(
                "  {}{}: {};\n",
                field.name, optional_marker, ts_type
            ));
        }

        output.push('}');
        output
    }

    fn generate_apex_methods(&self, class: &ApexClass) -> String {
        let mut output = String::new();
        
        // 各メソッドを @salesforce/apex からインポートする形式で定義
        for method in &class.methods {
            output.push_str(&self.generate_apex_import_declaration(class, method));
            output.push_str("\n");
        }

        output
    }

    fn generate_apex_import_declaration(&self, class: &ApexClass, method: &ApexMethod) -> String {
        let mut output = String::new();
        
        // declare function import のスタイル
        output.push_str(&format!(
            "declare module '@salesforce/apex/{}.{}' {{\n",
            class.name, method.name
        ));
        
        output.push_str("  export default function ");
        output.push_str(&method.name);
        output.push_str("(");
        
        // パラメータ
        if !method.parameters.is_empty() {
            output.push_str("params: {\n");
            for param in &method.parameters {
                let ts_type = self.convert_apex_type_to_ts(&param.param_type);
                output.push_str(&format!("    {}: {};\n", param.name, ts_type));
            }
            output.push_str("  }");
        }
        
        output.push_str("): Promise<");
        
        // 戻り値の型
        if method.return_type == "void" {
            output.push_str("void");
        } else {
            output.push_str(&self.convert_apex_type_to_ts(&method.return_type));
        }
        
        output.push_str(">;\n");
        output.push_str("}");
        
        output
    }

    fn convert_apex_type_to_ts(&self, apex_type: &str) -> String {
        match apex_type {
            "String" => "string".to_string(),
            "Integer" | "Long" | "Double" | "Decimal" => "number".to_string(),
            "Boolean" => "boolean".to_string(),
            "Date" | "DateTime" | "Time" => "string".to_string(), // ISO文字列として扱う
            "Id" => "string".to_string(),
            "Object" => "any".to_string(),
            _ => {
                // List<T>, Set<T>, Map<K,V> などのジェネリクスを処理
                if apex_type.starts_with("List<") || apex_type.starts_with("Set<") {
                    let inner = apex_type
                        .trim_start_matches("List<")
                        .trim_start_matches("Set<")
                        .trim_end_matches('>');
                    format!("{}[]", self.convert_apex_type_to_ts(inner))
                } else if apex_type.starts_with("Map<") {
                    // Map<K, V> を Record<K, V> に変換
                    let inner = apex_type.trim_start_matches("Map<").trim_end_matches('>');
                    let parts: Vec<&str> = inner.split(',').map(|s| s.trim()).collect();
                    if parts.len() == 2 {
                        format!(
                            "Record<{}, {}>",
                            self.convert_apex_type_to_ts(parts[0]),
                            self.convert_apex_type_to_ts(parts[1])
                        )
                    } else {
                        "Record<string, any>".to_string()
                    }
                } else {
                    // カスタムクラスはそのまま使用
                    apex_type.to_string()
                }
            }
        }
    }
}

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::ApexField;

    #[test]
    fn test_convert_primitive_types() {
        let generator = TypeScriptGenerator::new();
        assert_eq!(generator.convert_apex_type_to_ts("String"), "string");
        assert_eq!(generator.convert_apex_type_to_ts("Integer"), "number");
        assert_eq!(generator.convert_apex_type_to_ts("Boolean"), "boolean");
    }

    #[test]
    fn test_convert_list_type() {
        let generator = TypeScriptGenerator::new();
        assert_eq!(generator.convert_apex_type_to_ts("List<String>"), "string[]");
        assert_eq!(generator.convert_apex_type_to_ts("List<Integer>"), "number[]");
    }

    #[test]
    fn test_convert_map_type() {
        let generator = TypeScriptGenerator::new();
        assert_eq!(
            generator.convert_apex_type_to_ts("Map<String, Integer>"),
            "Record<string, number>"
        );
    }

    #[test]
    fn test_generate_interface() {
        let generator = TypeScriptGenerator::new();
        let class = ApexClass {
            name: "User".to_string(),
            fields: vec![
                ApexField {
                    name: "name".to_string(),
                    field_type: "String".to_string(),
                    is_optional: false,
                },
                ApexField {
                    name: "age".to_string(),
                    field_type: "Integer".to_string(),
                    is_optional: true,
                },
            ],
            methods: vec![],
        };

        let result = generator.generate_interface(&class);
        assert!(result.contains("export interface User"));
        assert!(result.contains("name: string;"));
        assert!(result.contains("age?: number;"));
    }
}
